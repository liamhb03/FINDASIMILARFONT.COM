<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Web Walkie Talkie</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 500px;
            margin: 0 auto;
            padding: 20px;
            text-align: center;
        }
        .container {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        .setup-container, .call-container {
            border: 1px solid #ccc;
            padding: 20px;
            border-radius: 10px;
        }
        #callButton {
            width: 200px;
            height: 200px;
            border-radius: 50%;
            background-color: #f44336;
            color: white;
            font-size: 18px;
            border: none;
            margin: 20px auto;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            transition: all 0.3s;
        }
        #callButton:active {
            background-color: #d32f2f;
            transform: scale(0.95);
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        #callButton:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }
        .input-group {
            margin-bottom: 15px;
        }
        input, button {
            padding: 10px;
            margin: 5px;
        }
        .status {
            font-weight: bold;
            margin: 10px 0;
        }
        .hidden {
            display: none;
        }
        #qrcode {
            margin: 10px auto;
        }
        .debug {
            margin-top: 20px;
            font-size: 12px;
            color: #666;
            text-align: left;
            border-top: 1px solid #eee;
            padding-top: 10px;
        }
    </style>
</head>
<body>
    <h1>Web Walkie Talkie</h1>
    
    <div class="container">
        <div class="setup-container" id="setupContainer">
            <h2>Setup Connection</h2>
            <div class="input-group">
                <label for="roomInput">Enter Room ID:</label>
                <input type="text" id="roomInput" placeholder="Enter a unique room ID">
                <button id="createRoomBtn">Create Room</button>
                <button id="joinRoomBtn">Join Room</button>
            </div>
            <p>Or scan this QR code to join:</p>
            <div id="qrcode"></div>
            <p class="status" id="setupStatus"></p>
        </div>
        
        <div class="call-container hidden" id="callContainer">
            <h2>Connected to: <span id="roomDisplay"></span></h2>
            <p class="status" id="connectionStatus">Waiting for peer...</p>
            <p>Press and hold to talk:</p>
            <button id="callButton" disabled>Press to Talk</button>
            <button id="disconnectBtn">Disconnect</button>
        </div>
        
        <div class="debug" id="debugInfo"></div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/peerjs/1.4.7/peerjs.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
    <script>
        // DOM elements
        const setupContainer = document.getElementById('setupContainer');
        const callContainer = document.getElementById('callContainer');
        const roomInput = document.getElementById('roomInput');
        const createRoomBtn = document.getElementById('createRoomBtn');
        const joinRoomBtn = document.getElementById('joinRoomBtn');
        const setupStatus = document.getElementById('setupStatus');
        const roomDisplay = document.getElementById('roomDisplay');
        const connectionStatus = document.getElementById('connectionStatus');
        const callButton = document.getElementById('callButton');
        const disconnectBtn = document.getElementById('disconnectBtn');
        const qrcodeDiv = document.getElementById('qrcode');
        const debugInfo = document.getElementById('debugInfo');
        
        // Variables for WebRTC
        let peer;
        let conn;
        let localStream;
        let call;
        let roomId;
        let isHost = false;
        let myPeerId = null;
        
        // Debug logging
        function logDebug(message) {
            const timestamp = new Date().toLocaleTimeString();
            debugInfo.innerHTML += `<div>[${timestamp}] ${message}</div>`;
            console.log(`[${timestamp}] ${message}`);
        }
        
        // Generate a random room ID if none provided
        roomInput.value = Math.random().toString(36).substring(2, 6);
        
        // Create QR code with current URL
        function generateQR(roomId, isJoining = true) {
            qrcodeDiv.innerHTML = '';
            const roomUrl = `${window.location.href.split('?')[0]}?${isJoining ? 'join=' : 'host='}${roomId}`;
            new QRCode(qrcodeDiv, {
                text: roomUrl,
                width: 128,
                height: 128
            });
            logDebug(`Generated QR for URL: ${roomUrl}`);
        }
        
        // Check URL for room parameter
        window.addEventListener('load', () => {
            const urlParams = new URLSearchParams(window.location.search);
            const joinRoom = urlParams.get('join');
            const hostRoom = urlParams.get('host');
            
            if (joinRoom) {
                roomInput.value = joinRoom;
                logDebug(`URL contains join parameter: ${joinRoom}`);
                joinRoomBtn.click();
            } else if (hostRoom) {
                roomInput.value = hostRoom;
                logDebug(`URL contains host parameter: ${hostRoom}`);
                createRoomBtn.click();
            } else {
                generateQR(roomInput.value);
            }
        });
        
        // Update QR code when room ID changes
        roomInput.addEventListener('input', () => {
            generateQR(roomInput.value);
        });
        
        // Custom PeerJS server options
        const peerOptions = {
            host: 'peerjs-server.herokuapp.com',
            secure: true,
            port: 443,
            debug: 3,
            config: {
                'iceServers': [
                    { urls: 'stun:stun.l.google.com:19302' },
                    { urls: 'stun:global.stun.twilio.com:3478?transport=udp' }
                ]
            }
        };
        
        // Setup audio
        async function setupAudio() {
            try {
                localStream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
                
                // Set up audio track to be disabled initially (muted)
                localStream.getAudioTracks().forEach(track => {
                    track.enabled = false;
                });
                
                logDebug('Audio setup successful');
                return true;
            } catch (err) {
                console.error('Failed to get local stream', err);
                logDebug(`Audio setup failed: ${err.message}`);
                connectionStatus.textContent = 'Error: Could not access microphone';
                return false;
            }
        }
        
        // Create a room (host)
        createRoomBtn.addEventListener('click', async () => {
            roomId = roomInput.value.trim();
            if (!roomId) {
                setupStatus.textContent = 'Please enter a room ID';
                return;
            }
            
            setupStatus.textContent = 'Creating room...';
            logDebug(`Creating room with ID: ${roomId}`);
            
            // Setup audio first
            const hasAudio = await setupAudio();
            if (!hasAudio) {
                setupStatus.textContent = 'Error: Could not access microphone';
                return;
            }
            
            // Create a peer with a random ID (more reliable than specifying an ID)
            peer = new Peer(peerOptions);
            isHost = true;
            
            peer.on('open', (id) => {
                myPeerId = id;
                setupStatus.textContent = `Room created! Your peer ID: ${id}`;
                roomDisplay.textContent = roomId;
                generateQR(roomId, false);
                logDebug(`Room created. Peer ID: ${id}`);
                
                // Switch to call container
                setupContainer.classList.add('hidden');
                callContainer.classList.remove('hidden');
                
                // Listen for connections
                peer.on('connection', (connection) => {
                    logDebug(`Incoming connection from a peer`);
                    conn = connection;
                    
                    conn.on('open', () => {
                        logDebug(`Connection open with peer: ${conn.peer}`);
                        handleConnection();
                    });
                    
                    conn.on('error', (err) => {
                        logDebug(`Connection error: ${err}`);
                        connectionStatus.textContent = `Connection error: ${err}`;
                    });
                });
                
                // Handle incoming calls
                peer.on('call', (incomingCall) => {
                    logDebug(`Incoming call from peer`);
                    call = incomingCall;
                    connectionStatus.textContent = 'Incoming call...';
                    
                    // Answer call with our stream
                    call.answer(localStream);
                    handleCall();
                });
            });
            
            peer.on('error', (err) => {
                logDebug(`Peer error: ${err.type} - ${err.message}`);
                setupStatus.textContent = `Error: ${err.message}`;
            });
        });
        
        // Join an existing room
        joinRoomBtn.addEventListener('click', async () => {
            roomId = roomInput.value.trim();
            if (!roomId) {
                setupStatus.textContent = 'Please enter a room ID';
                return;
            }
            
            setupStatus.textContent = 'Joining room...';
            logDebug(`Joining room with ID: ${roomId}`);
            
            // Setup audio first
            const hasAudio = await setupAudio();
            if (!hasAudio) {
                setupStatus.textContent = 'Error: Could not access microphone';
                return;
            }
            
            // Create peer with random ID
            peer = new Peer(peerOptions);
            isHost = false;
            
            peer.on('open', (id) => {
                myPeerId = id;
                setupStatus.textContent = `Your peer ID: ${id}. Connecting to room: ${roomId}...`;
                roomDisplay.textContent = roomId;
                logDebug(`Your peer ID: ${id}. Attempting to connect to host.`);
                
                // Switch to call container
                setupContainer.classList.add('hidden');
                callContainer.classList.remove('hidden');
                
                // Connect to all available peers in the mesh
                logDebug(`Attempting to connect to known hosts for room: ${roomId}`);
                
                // Try to connect to the peer with the roomId
                conn = peer.connect(roomId, {
                    reliable: true
                });
                
                // Connection established
                conn.on('open', () => {
                    logDebug(`Connection established with peer: ${conn.peer}`);
                    handleConnection();
                    
                    // Create a call to the peer
                    logDebug(`Initiating call to peer: ${conn.peer}`);
                    call = peer.call(conn.peer, localStream);
                    handleCall();
                });
                
                // Connection failed
                conn.on('error', (err) => {
                    logDebug(`Connection error: ${err}`);
                    connectionStatus.textContent = `Connection error: ${err}`;
                });
            });
            
            peer.on('error', (err) => {
                logDebug(`Peer error: ${err.type} - ${err.message}`);
                setupStatus.textContent = `Error: ${err.message}`;
            });
        });
        
        // Handle connection
        function handleConnection() {
            connectionStatus.textContent = 'Connected to peer!';
            logDebug(`Connection established with peer: ${conn.peer}`);
            
            callButton.disabled = false;
            
            conn.on('data', (data) => {
                logDebug(`Received data: ${JSON.stringify(data)}`);
                // You could implement text messaging here if desired
            });
            
            conn.on('close', () => {
                logDebug(`Connection closed with peer: ${conn.peer}`);
                connectionStatus.textContent = 'Peer disconnected';
                callButton.disabled = true;
            });
        }
        
        // Handle call
        function handleCall() {
            logDebug(`Call handler setup`);
            
            call.on('stream', (remoteStream) => {
                logDebug(`Received remote stream`);
                // Create audio element for remote stream
                const audio = document.createElement('audio');
                audio.srcObject = remoteStream;
                audio.id = 'remoteAudio';
                audio.autoplay = true;
                document.body.appendChild(audio);
                
                connectionStatus.textContent = 'Connected! Audio channel established.';
                logDebug(`Audio element created and playing remote stream`);
            });
            
            call.on('close', () => {
                logDebug(`Call closed`);
                const audio = document.getElementById('remoteAudio');
                if (audio) audio.remove();
                connectionStatus.textContent = 'Call ended';
            });
            
            call.on('error', (err) => {
                logDebug(`Call error: ${err}`);
                connectionStatus.textContent = `Call error: ${err}`;
            });
        }
        
        // Push-to-talk functionality
        callButton.addEventListener('mousedown', () => {
            if (localStream) {
                localStream.getAudioTracks().forEach(track => {
                    track.enabled = true;
                });
                callButton.textContent = 'Talking...';
                logDebug(`Microphone activated`);
            }
        });
        
        callButton.addEventListener('mouseup', () => {
            if (localStream) {
                localStream.getAudioTracks().forEach(track => {
                    track.enabled = false;
                });
                callButton.textContent = 'Press to Talk';
                logDebug(`Microphone deactivated`);
            }
        });
        
        // For touch devices
        callButton.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (localStream) {
                localStream.getAudioTracks().forEach(track => {
                    track.enabled = true;
                });
                callButton.textContent = 'Talking...';
                logDebug(`Microphone activated (touch)`);
            }
        });
        
        callButton.addEventListener('touchend', () => {
            if (localStream) {
                localStream.getAudioTracks().forEach(track => {
                    track.enabled = false;
                });
                callButton.textContent = 'Press to Talk';
                logDebug(`Microphone deactivated (touch)`);
            }
        });
        
        // Disconnect button
        disconnectBtn.addEventListener('click', () => {
            logDebug(`Disconnecting...`);
            if (call) call.close();
            if (conn) conn.close();
            if (peer) peer.destroy();
            
            // Return to setup
            callContainer.classList.add('hidden');
            setupContainer.classList.remove('hidden');
            setupStatus.textContent = '';
            
            // Cleanup
            if (localStream) {
                localStream.getTracks().forEach(track => track.stop());
                localStream = null;
            }
            
            const audio = document.getElementById('remoteAudio');
            if (audio) audio.remove();
            
            // Generate a new random room ID
            roomInput.value = Math.random().toString(36).substring(2, 6);
            generateQR(roomInput.value);
            logDebug(`Disconnected and reset`);
        });
    </script>
</body>
</html>