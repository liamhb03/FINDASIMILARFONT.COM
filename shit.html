<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simple Walkie Talkie</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 500px;
            margin: 0 auto;
            padding: 20px;
            text-align: center;
        }
        .container {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        .panel {
            border: 1px solid #ccc;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
        }
        .button {
            padding: 10px;
            margin: 5px;
            border-radius: 5px;
            border: 1px solid #ccc;
            background-color: #f5f5f5;
            cursor: pointer;
        }
        #roomInput {
            padding: 10px;
            width: 200px;
            margin: 5px;
        }
        .talk-button {
            width: 200px;
            height: 200px;
            border-radius: 50%;
            background-color: #f44336;
            color: white;
            font-size: 18px;
            border: none;
            margin: 20px auto;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            transition: all 0.3s;
        }
        .talk-button:active {
            background-color: #d32f2f;
            transform: scale(0.95);
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        .talk-button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }
        .status {
            font-weight: bold;
            margin: 10px 0;
        }
        .hidden {
            display: none;
        }
        .logs {
            text-align: left;
            font-family: monospace;
            font-size: 12px;
            max-height: 150px;
            overflow-y: auto;
            border: 1px solid #eee;
            padding: 10px;
            margin-top: 20px;
        }
    </style>
</head>
<body>
    <h1>Simple Walkie Talkie</h1>
    
    <div class="container">
        <div class="panel" id="setupPanel">
            <h2>Enter Room</h2>
            <p>Both users need to enter the same room name:</p>
            <input type="text" id="roomInput" placeholder="Enter room name" value="testroom">
            <button class="button" id="joinBtn">Join Room</button>
            <p class="status" id="setupStatus"></p>
        </div>
        
        <div class="panel hidden" id="callPanel">
            <h2>Room: <span id="roomName"></span></h2>
            <p class="status" id="peerStatus">Waiting for peer...</p>
            <p>Press and hold to talk:</p>
            <button class="talk-button" id="talkBtn" disabled>Press to Talk</button>
            <button class="button" id="leaveBtn">Leave Room</button>
        </div>
        
        <div class="logs" id="logPanel"></div>
    </div>

    <!-- Simple-Peer for WebRTC -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/simple-peer/9.11.1/simplepeer.min.js"></script>
    <script>
        // DOM elements
        const setupPanel = document.getElementById('setupPanel');
        const callPanel = document.getElementById('callPanel');
        const roomInput = document.getElementById('roomInput');
        const joinBtn = document.getElementById('joinBtn');
        const setupStatus = document.getElementById('setupStatus');
        const roomName = document.getElementById('roomName');
        const peerStatus = document.getElementById('peerStatus');
        const talkBtn = document.getElementById('talkBtn');
        const leaveBtn = document.getElementById('leaveBtn');
        const logPanel = document.getElementById('logPanel');
        
        // Variables
        let localStream;
        let isTalking = false;
        let peers = [];
        let connectedPeers = 0;
        
        // Logging function
        function log(message) {
            const timestamp = new Date().toLocaleTimeString();
            logPanel.innerHTML += `<div>[${timestamp}] ${message}</div>`;
            logPanel.scrollTop = logPanel.scrollHeight;
            console.log(`[${timestamp}] ${message}`);
        }
        
        // Initialize peer connection with WebRTC
        async function initializeWebRTC() {
            try {
                log("Getting audio stream...");
                localStream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
                
                // Mute the stream initially
                localStream.getAudioTracks().forEach(track => {
                    track.enabled = false;
                });
                
                log("Audio stream initialized");
                return true;
            } catch (error) {
                log(`Error getting media stream: ${error.message}`);
                setupStatus.textContent = `Microphone error: ${error.message}`;
                return false;
            }
        }
        
        // Secure hash function for room name
        async function hashRoomName(roomName) {
            const encoder = new TextEncoder();
            const data = encoder.encode(roomName);
            const hashBuffer = await crypto.subtle.digest('SHA-256', data);
            const hashArray = Array.from(new Uint8Array(hashBuffer));
            const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
            return hashHex;
        }
        
        // Create a peer connection
        function createPeer(initiator) {
            log(`Creating peer (initiator: ${initiator})`);
            
            const peer = new SimplePeer({
                initiator: initiator,
                stream: localStream,
                trickle: false,
                config: {
                    iceServers: [
                        { urls: 'stun:stun.l.google.com:19302' },
                        { urls: 'stun:stun1.l.google.com:19302' },
                        { urls: 'stun:stun2.l.google.com:19302' }
                    ]
                }
            });
            
            peer.on('signal', data => {
                // Convert signal data to base64 string
                const signalString = btoa(JSON.stringify(data));
                log(`Generated signal data (${data.type})`);
                
                // Add the signal to local storage with timestamp (used for signaling)
                const timestamp = Date.now();
                const roomKey = roomInput.value;
                const signalData = {
                    timestamp,
                    signal: signalString,
                    isInitiator: initiator
                };
                
                // Append to existing signals or create new array
                const existingSignals = JSON.parse(localStorage.getItem(roomKey) || '[]');
                existingSignals.push(signalData);
                localStorage.setItem(roomKey, JSON.stringify(existingSignals));
                
                log(`Signal saved to localStorage (${data.type})`);
            });
            
            peer.on('connect', () => {
                connectedPeers++;
                log(`Peer connected! Total connections: ${connectedPeers}`);
                peerStatus.textContent = `Connected to peer!`;
                talkBtn.disabled = false;
                
                // Send initial test data
                peer.send(JSON.stringify({ type: 'ping', timestamp: Date.now() }));
            });
            
            peer.on('data', data => {
                const message = JSON.parse(data);
                log(`Received data: ${message.type}`);
                
                if (message.type === 'ping') {
                    peer.send(JSON.stringify({ type: 'pong', timestamp: Date.now() }));
                }
            });
            
            peer.on('stream', stream => {
                log(`Remote stream received`);
                
                // Create an audio element to play the remote stream
                const audio = document.createElement('audio');
                audio.srcObject = stream;
                audio.id = 'remoteAudio';
                audio.play();
                document.body.appendChild(audio);
            });
            
            peer.on('error', err => {
                log(`Peer error: ${err.message}`);
            });
            
            peer.on('close', () => {
                log(`Peer connection closed`);
                connectedPeers--;
                if (connectedPeers === 0) {
                    peerStatus.textContent = 'Waiting for peer...';
                    talkBtn.disabled = true;
                }
            });
            
            return peer;
        }
        
        // Start signaling process
        async function startSignaling() {
            const roomKey = roomInput.value;
            log(`Starting signaling for room: ${roomKey}`);
            
            // Create a peer as initiator first
            const initiatorPeer = createPeer(true);
            peers.push(initiatorPeer);
            
            // Create a peer as non-initiator to accept incoming connections
            const receiverPeer = createPeer(false);
            peers.push(receiverPeer);
            
            // Poll local storage for signals every 1 second
            const signalInterval = setInterval(() => {
                try {
                    const signals = JSON.parse(localStorage.getItem(roomKey) || '[]');
                    
                    // Process new signals (that we haven't processed yet)
                    signals.forEach((signalData, index) => {
                        // Skip our own signals
                        if (signalData.processed) {
                            return;
                        }
                        
                        // Mark as processed
                        signals[index].processed = true;
                        
                        try {
                            // Decode the signal
                            const signalObj = JSON.parse(atob(signalData.signal));
                            log(`Processing signal (${signalObj.type})`);
                            
                            // Send to appropriate peer
                            if (signalData.isInitiator) {
                                receiverPeer.signal(signalObj);
                            } else {
                                initiatorPeer.signal(signalObj);
                            }
                        } catch (e) {
                            log(`Error processing signal: ${e.message}`);
                        }
                    });
                    
                    // Update localStorage with processed flags
                    localStorage.setItem(roomKey, JSON.stringify(signals));
                } catch (e) {
                    log(`Error in signal processing: ${e.message}`);
                }
            }, 1000);
            
            // Store interval for cleanup
            window.signalInterval = signalInterval;
        }
        
        // Join room button handler
        joinBtn.addEventListener('click', async () => {
            const room = roomInput.value.trim();
            if (!room) {
                setupStatus.textContent = 'Please enter a room name';
                return;
            }
            
            setupStatus.textContent = 'Initializing...';
            log(`Joining room: ${room}`);
            
            // Initialize WebRTC
            const success = await initializeWebRTC();
            if (!success) {
                return;
            }
            
            // Switch to call panel
            setupPanel.classList.add('hidden');
            callPanel.classList.remove('hidden');
            roomName.textContent = room;
            
            // Start signaling
            startSignaling();
        });
        
        // Push-to-talk functionality
        talkBtn.addEventListener('mousedown', () => {
            if (localStream) {
                localStream.getAudioTracks().forEach(track => {
                    track.enabled = true;
                });
                talkBtn.textContent = 'Talking...';
                isTalking = true;
                log(`Microphone activated`);
            }
        });
        
        talkBtn.addEventListener('mouseup', () => {
            if (localStream) {
                localStream.getAudioTracks().forEach(track => {
                    track.enabled = false;
                });
                talkBtn.textContent = 'Press to Talk';
                isTalking = false;
                log(`Microphone deactivated`);
            }
        });
        
        // For touch devices
        talkBtn.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (localStream) {
                localStream.getAudioTracks().forEach(track => {
                    track.enabled = true;
                });
                talkBtn.textContent = 'Talking...';
                isTalking = true;
                log(`Microphone activated (touch)`);
            }
        });
        
        talkBtn.addEventListener('touchend', () => {
            if (localStream) {
                localStream.getAudioTracks().forEach(track => {
                    track.enabled = false;
                });
                talkBtn.textContent = 'Press to Talk';
                isTalking = false;
                log(`Microphone deactivated (touch)`);
            }
        });
        
        // Leave room button handler
        leaveBtn.addEventListener('click', () => {
            log(`Leaving room`);
            
            // Close all peer connections
            peers.forEach(peer => {
                if (peer) peer.destroy();
            });
            peers = [];
            
            // Clear interval
            if (window.signalInterval) {
                clearInterval(window.signalInterval);
            }
            
            // Stop media tracks
            if (localStream) {
                localStream.getTracks().forEach(track => track.stop());
                localStream = null;
            }
            
            // Remove remote audio
            const remoteAudio = document.getElementById('remoteAudio');
            if (remoteAudio) remoteAudio.remove();
            
            // Reset UI
            setupPanel.classList.remove('hidden');
            callPanel.classList.add('hidden');
            setupStatus.textContent = '';
            connectedPeers = 0;
            
            // Generate a new room name
            roomInput.value = 'room' + Math.floor(Math.random() * 1000);
        });
        
        // Set a random room name
        roomInput.value = 'room' + Math.floor(Math.random() * 1000);
        
        // Handle page unload - clean up
        window.addEventListener('beforeunload', () => {
            if (window.signalInterval) {
                clearInterval(window.signalInterval);
            }
            peers.forEach(peer => {
                if (peer) peer.destroy();
            });
            if (localStream) {
                localStream.getTracks().forEach(track => track.stop());
            }
        });
    </script>
</body>
</html>